\paragraph{Justification de la modélisation choisie}

\subparagraph{Machine 1: envoi des wagons par le biais d'un buffer}

La première machine se découpe comme suit. Tout d'abord, nous avons créé un
tableau ``tabVoie'' qui prend des indices compris entre 1 et ``nbWagons'',
constante définie dans le contexte c1, appartenant aux entiers positifs
supérieurs à 0, et retourne un champ appartenant à ``TOWN''. Cette dernière
est une partition. C'est-à-dire que sa valeur est l'un des deux champs
suivants: ``Toulouse'' ou ``Bayonne''. La voie est donc un tableau composé
de villes, ``tabVoie(i)'' désignant la ville à laquelle le wagon ``i''
doit aller.
\\
Nous avons décidé de créer directement une machine gérant les wagons par
groupe. Ainsi, nous avons créé 2 ensembles, ``ensToulouse'' et ``ensBayonne''
dans lesquels nous stockerons les indices de ``tabVoie'' une fois que les wagons
seront envoyés. Nous avons décidé de créer des ensembles et non des tableaux
pour ces voies car l'ordre important peu, il est plus aisé de manipuler
des ensembles que des indices sur ces deux voies. Ensuite, nous avons un ensemble
``ensBuffer'' qui servira à stocker les groupes de wagons à la suite allant dans
la même direction. Nous avons aussi créé un booléen ``ready'' qui, une fois passé
à ``TRUE'', indiquera à ``ensBuffer'' qu'il faut envoyer l'ensemble dans la voie
correspondante. Enfin nous avons un système d'index. ``currentIndex'' désigne
le début du groupe de wagons que nous sommes actuellement en train de traiter
et ``nextWagonIndex'' devra être incrémenté jusqu'à atteindre l'indice après ce
groupe de wagons. Ainsi, lorsque ``ready'' sera à ``TRUE'', nous enverrons tous
les indices de ``tabVoie'' compris entre ``currentIndex'' et ``nextWagonIndex - 1''
dans l'ensemble correspondant à la ville de ``tabVoie(currentIndex)''. Une fois cela
effectué, on peut passer le ``currentIndex'' à ``nextWagonIndex''.
\\
L'initialisation doit tout d'abord mettre nos trois ensembles égaux à l'ensemble vide.
Ensuite, nous deux index se positionnent à 1, premier wagon à analyser, et ``ready''
est égal à ``FALSE''. L'évènement ``incIndex'' sert à incrémenter ``nextWagonIndex''.
Si l'envoi de wagons n'est pas prêt et que ``nextWagonIndex'' désigne bien un wagon
sur la voie, et que ``currentIndex'' et ``nextWagonIndex'' désignent des
wagons allant à la même destination, on incrémente ``nextWagonIndex''.
L'évènement ``bufferWagons'' sert à bufferiser l'ensemble prêt à être envoyé. Il y a
ainsi deux conditions d'arrêt afin d'envoyer un groupe de wagons dans le buffer,
soit ``tabVoie(nextWagonIndex)'' désigne une ville différente de
``tabVoie(currentIndex)'', soit ``nextWagonIndex'' est égal à ``nbWagons + 1'', auquel
cas on enverra le dernier groupe de wagons. Cet évènement remplit donc ``ensBuffer''
et passe le booléen ``ready'' à ``TRUE''. Ce changement de valeur garantit qu'on
bloque les évènements ``incIndex'' et ``bufferWagons''. Désormais, seuls les envois
de wagons sont possibles.
Ainsi, quand ``ready'' est à ``TRUE'', nous nous retrouvons dans deux situations.
Soit les élèments de ``ensBuffer'' sont égaux à Toulouse et l'on envoie tout dans
``ensToulouse'', soit c'est Bayonne et l'on envoie tout dans ``ensBayonne''. Cela
correspond ainsi à faire l'union de l'ensemble actuel des villes avec ``ensBuffer''.
Par la suite, on reset le booléen ``ready'' à ``FALSE'' et ``ensBuffer'' à l'ensemble
vide et on passe ``currentIndex'' à la valeur ``nextWagonIndex''.
\\
Les invariants garantissent que ``currentIndex'' est toujours inférieur ou égal à
``nextWagonIndex'' et que pour tout ``i'' appartenant à l'ensemble d'une ville,
``tabVoie(i)'' retourne bien la ville correspondante. Enfin, on garantit que quand
``ready'' est à ``TRUE'', tout ``i'' compris entre ``currentIndex'' et ``nextWagonIndex-1'' est compris dans ``ensBuffer''.


\subparagraph{Machine 2: Ajout de la fonctionalité de l'aiguillage et du feu}



La machine 2 est la machine permettant d'intégrer la fonctionnalité des switchs et des feux à la machine 1, et est donc la machine finale, la plus évoluée de notre projet, gérant toutes fonctionnalitées demandées.
//
Elle utilise le contexte c2,  dans lequel COLOR est instanciée: COLOR est une  partition contenant les deux couleurs du feu, Red et Green, qui va nous servir à représenter la fonctionnalité d'un feu.
Le contexte c2 étends aussi le contexte c1, et possède donc aussi la partition TOWN, contenant Toulouse et Bayonne, le tableau tabVoie contenant les wagons, et enfin nbWagons qui représente la taille des wagons.

La machine m2_switch_light raffine la machine m1_buffer, elle possède donc les mêmes fonctionnalités avec en plus l'ajout du système des feux/aiguillage.

La machine m2_switch_light possède 8 variables, donc 3 nouveaux :

-switch , variable qui va représenter le système d'aiguillage, qui va donc contenir la destination de l'aiguillage actuelle.
-light  , variable qui va représenter le système de feu, qui va donc contenir la couleur du feu actuelle.
-ready  , booléen qui est true lorsque l'aiguillage est en destination de la même ville contenue dans ensBuffer

Les invariants de la machine m2_switch_light sont donc:
    -light est une couleur
    -switch est une destination
    -Pour tout i appartenant à ensBuffer et le booléan ready est sur true, alors tabVoie(i) est bien la même destination de switch

L'initialisation de la machine m2_switch_light ne change pas à celle de la machine m1_buffer, hormis qu'elle met light à rouge, car la mettre à vert engendrait des erreurs, et switch à Toulouse, choisi arbitrairement.

Les évènements incIndex et bufferWagons sont étendues normalement, contrairement aux évenements fromBufferToToulouse et fromBufferToBayonne:

Concernant tout d'abord les gardes:
- On vérifie d'abord que ready est bien à TRUE, que le switch a bien la même destination que la ville concernée, et que le feu est vert.

- On vérifie que tout élément d'ensBuffer ont bien pour destination la ville concernée

- On vérifie que pour tout 2  éléments d'ensBuffer ont bien la même ville.

Nous appliquons donc après en actions :

- On assigne à l'ensemble des wagons de la ville concernée tout les éléments présents dans ensBuffer

- On remet ensBuffer vide.

- On met ready à FALSE.

- On met le currentIndex à la position de nextWagonIndex, symbolisant que la partie autrefois entre currentIndex et nextWagonIndex a bien été traité.

Nous avons ensuite les 2 évenements gérant la gestion du feu:

lightChangeToGreen met le feu à vert que lorsque le feu est rouge et que ready est sur TRUE avec tout élément de ensBuffer donnant en destination la même ville que le switch.

lightChangeToRed quant à lui va mettre le feu au rouge lorsque que le feu est vert est que ready est sur FALSE.

Enfin nous allons terminer avec les 2 évènements gérant la fonctionnalité de l'aiguillage, switchChangeToToulouse et switchChangeToBayonne:

Pour la ville Toulouse par exemple:

Chacun de ces évènements possèdent en garde le fait que le feu doit être rouge, que la destination de l'aiguillage est sur la ville Toulouse , et que ready soit sur false, avec le currentIndex inférieur ou égale à nbWagons, et avec tabVoie(currentIndex) à destination de la ville Bayonne.
Si toutes ces gardes sont respectées, alors on change l'aiguillage vers la ville Toulouse.

Cela est identique pour la ville de Bayonne, en inversant les villes de la fonction switchChangeToToulouse.
